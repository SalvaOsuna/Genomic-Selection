setwd("~/GitHub/Genomic-Selection/Genomic Selection_SALVA/data")
#Ahora voy a hacer lo mismo con GROAN intentando 50 rep. de 10 fold cross-validation:
library(GROAN)
# 4) Input phenotype. Traits in a matrix format. rows = GEN; column = trait
Pheno_rust <- as.matrix(read.xlsx(xlsxFile = "BLUP_field.xlsx", sep= "\t", rowNames = F, colNames = T, sheet = "BLUP_GS_rust"))
# 3) Impute your data "filling" all the NA's (SVDI)
library(bcv)
library(rrBLUP)
# 1) Load required packages and load files:
library(openxlsx)
# 4) Input phenotype. Traits in a matrix format. rows = GEN; column = trait
Pheno_rust <- as.matrix(read.xlsx(xlsxFile = "BLUP_field.xlsx", sep= "\t", rowNames = F, colNames = T, sheet = "BLUP_GS_rust"))
head(Pheno_rust)
#HERE WE GO AGAIN. NOW WITH SCALED FIELD DATA####
R_scaled <- read.xlsx("BLUPs_scaled.xlsx")
library(readxl)
#HERE WE GO AGAIN. NOW WITH SCALED FIELD DATA####
R_scaled <- read.xlsx("BLUPs_scaled.xlsx")
#HERE WE GO AGAIN. NOW WITH SCALED FIELD DATA####
R_scaled <- read.xlsx("./BLUPs_scaled.xlsx")
setwd("~/GitHub/Genomic-Selection/Genomic Selection_SALVA")
#HERE WE GO AGAIN. NOW WITH SCALED FIELD DATA####
R_scaled <- read.xlsx("BLUPs_scaled.xlsx")
head(R_scaled)
#Ahora voy a hacer lo mismo con GROAN intentando 50 rep. de 10 fold cross-validation:
library(GROAN)
DArT <- as.matrix(read.table("DArT.txt", header = T))
DArT[DArT == 1] <- 2 #change 1 to 2
DArT_GROAN <- DArT[-c(288, 294, 300, 320, 325), ] #Estas entradas no están evaluadas en CC así que las quito
DArT_GROAN_SVDI <-
impute.svd(DArT_GROAN, # data matrix with missing values
k = 4, #the rank of the SVD approximation, I use k = 4 following Nazzicari, N. 2016
#tol = max(24279, 325) * 1e-10, #the convergence tolerance for the EM algorithm
maxiter = 100 #the maximum number of EM steps to take
)$x
DArT_GROAN_SVDI[DArT_GROAN_SVDI >= 1.5] <- 2
DArT_GROAN_SVDI[DArT_GROAN_SVDI <= 0.5] <- 0
DArT_GROAN_SVDI[DArT_GROAN_SVDI > 0.5 & DArT_GROAN_SVDI < 1.5]<- 1
setwd("~/GitHub/Genomic-Selection/Genomic Selection_SALVA/data")
DArT <- as.matrix(read.table("DArT.txt", header = T))
DArT[DArT == 1] <- 2 #change 1 to 2
DArT_GROAN <- DArT[-c(288, 294, 300, 320, 325), ] #Estas entradas no están evaluadas en CC así que las quito
DArT_GROAN_SVDI <-
impute.svd(DArT_GROAN, # data matrix with missing values
k = 4, #the rank of the SVD approximation, I use k = 4 following Nazzicari, N. 2016
#tol = max(24279, 325) * 1e-10, #the convergence tolerance for the EM algorithm
maxiter = 100 #the maximum number of EM steps to take
)$x
DArT_GROAN_SVDI[DArT_GROAN_SVDI >= 1.5] <- 2
DArT_GROAN_SVDI[DArT_GROAN_SVDI <= 0.5] <- 0
DArT_GROAN_SVDI[DArT_GROAN_SVDI > 0.5 & DArT_GROAN_SVDI < 1.5]<- 1
DArT_GROAN_SVDI <- as.data.frame(DArT_GROAN_SVDI)
#creating a dataset for Rust (3fields)
Pheno_rust_df$Rust <- as.numeric(Pheno_rust_df$Rust)
nds.R18 = createNoisyDataset(
name = 'R18',
genotypes = DArT_GROAN_SVDI,
phenotypes = R_scaled$R18
)
nds.R20 = createNoisyDataset(
name = 'R20',
genotypes = DArT_GROAN_SVDI,
phenotypes = R_scaled$R20
)
nds.DS = createNoisyDataset(
name = 'R20',
genotypes = DArT_GROAN_SVDI,
phenotypes = R_scaled$DS
)
nds.Index = createNoisyDataset(
name = 'R20',
genotypes = DArT_GROAN_SVDI,
phenotypes = R_scaled$I_cc_FAI
)
nds.mega = createNoisyDataset(
name = 'R20',
genotypes = DArT_GROAN_SVDI,
phenotypes = R_scaled$Rust
)
wb = createWorkbench(
#parameters defining crossvalidation
folds = 10, reps = 50, stratified = FALSE,
#parameters defining save-on-hard-disk policy
outfolder = NULL, saveHyperParms = FALSE, saveExtraData = FALSE,
#a regressor
regressor = phenoRegressor.rrBLUP, regressor.name = 'rrBLUP'
)
wb2 = addRegressor(wb, regressor = phenoRegressor.BGLR, type = "BL", regressor.name = "BL"
)
wb2
#Matrix design
geno <- data.frame(read.xlsx("GenPea_SilDArT_Kinship_rust.xlsx", sheet = "Sheet 1", colNames = T, rowNames = T))
View(geno)
wb3 = addRegressor(wb2, regressor = phenoRegressor.BGLR(type = "RKHS", covariances = geno),
regressor.name = "GBLUP")
wb3 = addRegressor(wb2, regressor = phenoRegressor.BGLR(phenotypes = ,type = "G-BLUP", covariances = geno),
regressor.name = "GBLUP")
wb2 = addRegressor(wb, regressor = phenoRegressor.BGLR, type = "BL", regressor.name = "BL"
)
wb2
res_DSvsmega = GROAN.run(
nds = nds.DS, wb = wb2,
nds.test = nds.mega
)
res_DSvsmega %>%
group_by(dataset.train, dataset.test) %>%
summarise("meanPA" = mean(pearson))
plotResult(res_DSvsmega)
res_Indexvsmega = GROAN.run(
nds = nds.Index, wb = wb2,
nds.test = nds.mega
)
res_Indexvsmega %>%
group_by(dataset.train, dataset.test) %>%
summarise("meanPA" = mean(pearson))
plotResult(res_Indexvsmega)
res_summary2 <- rbind(res_DSvsmega, res_Indexvsmega)
plotResult(res_summary2)
write.xlsx(res_summary2, "acrossENV_BLrr_DS_Index_mega.xlsx")
nds.mega
nds.DS = createNoisyDataset(
name = 'DS',
genotypes = DArT_GROAN_SVDI,
phenotypes = R_scaled$DS
)
nds.Index = createNoisyDataset(
name = 'Index',
genotypes = DArT_GROAN_SVDI,
phenotypes = R_scaled$I_cc_FAI
)
nds.mega = createNoisyDataset(
name = 'MegaENV',
genotypes = DArT_GROAN_SVDI,
phenotypes = R_scaled$Rust
)
res_DSvsmega = GROAN.run(
nds = nds.DS, wb = wb2,
nds.test = nds.mega
)
res_DSvsmega %>%
group_by(dataset.train, dataset.test) %>%
summarise("meanPA" = mean(pearson))
plotResult(res_DSvsmega)
res_Indexvsmega = GROAN.run(
nds = nds.Index, wb = wb2,
nds.test = nds.mega
)
res_Indexvsmega %>%
group_by(dataset.train, dataset.test) %>%
summarise("meanPA" = mean(pearson))
plotResult(res_Indexvsmega)
res_summary2 <- rbind(res_DSvsmega, res_Indexvsmega)
plotResult(res_summary2)
write.xlsx(res_summary2, "acrossENV_BLrr_DS_Index_mega.xlsx")
library(tidyverse)
res_DSvsmega %>%
group_by(dataset.train, dataset.test) %>%
summarise("meanPA" = mean(pearson))
res_Indexvsmega %>%
group_by(dataset.train, dataset.test) %>%
summarise("meanPA" = mean(pearson))
res_summary2 <- rbind(res_DSvsmega, res_Indexvsmega)
plotResult(res_summary2)
write.xlsx(res_summary2, "acrossENV_BLrr_DS_Index_mega.xlsx")
